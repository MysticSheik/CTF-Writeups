from Crypto.Cipher import ARC4
from Crypto.Cipher import AES
import ctypes

with open("malware.elf", "rb") as f:
    data = f.read()
    data = bytearray(data)
    
    # Encrypted Config Section Start and End Addr.
    KDD_S = 0x51A0
    KDD_E = 0x5397

    # CBC-Encrypted Section Start and End Addr.
    ECO_S = 0x53A0
    ECO_E = 0x5BF6
    
    rc4_key = data[0x4010:0x4030]
    ivValueData = data[0x4036:0x403a]
    keyValueData = data[0x403b:0x403f]

# Translation of SUB_1A19
def rc4_decrypt(key, mem_address):
    offset = mem_address + 1

    cipher = ARC4.new(key)
    decBytes = b'\x00' * 0x31 # Simulate calloc(0x31, 1)
    decBytes = cipher.decrypt(decBytes)
    
    # Ad-hoc crypto hell
    counter = 0x30
    while(-1 < counter):
        temp = (counter + decBytes[counter]) % 0x31
        prev = data[offset + counter]
        data[offset + counter] = data[offset + temp]
        data[offset + temp] = prev
        counter = counter + -1
    data_to_decrypt = data[offset:offset+0x31]
    decBytes = cipher.decrypt(data_to_decrypt)
    data[offset:offset+0x31] = decBytes
    print(decBytes.decode())

# Translation of SUB_1BBF
def d_sub_b():
    counter = 0
    while counter < 10:
        if (data[KDD_S + counter * 0x32] & 4) != 0:
            rc4_decrypt(rc4_key, KDD_S + counter * 0x32)
            data[KDD_S + counter * 0x32] = 8
        counter += 1

# Translation of SUB_2ECE
def derive_key(keyValue):
    counter = 0
    while True:
        if 9 < counter:
            d_sub_b()
            recValue = derive_key(keyValue)
            return recValue
        ind = counter * 0x32 + 0x51a1
        if (data[KDD_S + counter*0x32] & 8) and keyValue in data[ind:ind+4]:
            break
        counter += 1
    return counter * 0x32 + 0x51a5

def decrypt_config(number):
    iv = derive_key(ivValueData)
    key = derive_key(keyValueData)
    iv = bytes(data[iv:iv+16])
    key = bytes(data[key:key+32])

    cbc = AES.new(key, AES.MODE_CBC, IV=iv)
    ind = number * 0x61 + 1
    data_to_decrypt = data[ECO_S+ind:ECO_S+ind+0x60]
    decrypted_data = cbc.decrypt(data_to_decrypt)
    data[ECO_S+ind:ECO_S+ind+0x60] = decrypted_data

for i in range(22):
    decrypt_config(i)

print(bytes(data[ECO_S:ECO_E]).decode())
