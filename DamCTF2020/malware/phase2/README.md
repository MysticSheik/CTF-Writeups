## malware/phase2
>Nice work finding that suspicious file! Using IcyRetina's extensive collection of Yara rules, you were able to identify that the sample is definitely malicious, but very little is known about it. Can you extract the config from the malware?

>There is a chunk of encrypted data that is accessed early on in the malware's execution. That is the the malware's config.

OpenSSL / libcrypto reference manual:
https://www.openssl.org/docs/man1.1.0/man3/EVP_CIPHER_CTX_new.html

* Initial triage: strings showing external calls to libcrypto and libc
* Binaryninja + Ghidra: Subroutine starting at 0x00102ece seems to be the subroutine for decrypting the config. Uses AES-256-CBC from OpenSSL/libcrypto

Script:
* RC4 Key is stored at 0x4010 - 0x4030
* Encrypted Data is stored somewhere between 0x53A0 - 0x5BF6
* Encrypted Config Data is stored at 0x51A0 - 0x5397
* IV Config Value is stored at 0x4036 - 0x403A
* Key Config Value is stored at 0x403B - 0x403F

```python=
from Crypto.Cipher import ARC4
from Crypto.Cipher import AES
import ctypes

with open("malware.elf", "rb") as f:
    data = f.read()
    data = bytearray(data)
    
    # Encrypted Config Section Start and End Addr.
    KDD_S = 0x51A0
    KDD_E = 0x5397

    # CBC-Encrypted Section Start and End Addr.
    ECO_S = 0x53A0
    ECO_E = 0x5BF6
    
    rc4_key = data[0x4010:0x4030]
    ivValueData = data[0x4036:0x403a]
    keyValueData = data[0x403b:0x403f]

# Translation of SUB_1A19
def rc4_decrypt(key, mem_address):
    offset = mem_address + 1

    cipher = ARC4.new(key)
    decBytes = b'\x00' * 0x31 # Simulate calloc(0x31, 1)
    decBytes = cipher.decrypt(decBytes)
    
    # Ad-hoc crypto hell
    counter = 0x30
    while(-1 < counter):
        temp = (counter + decBytes[counter]) % 0x31
        prev = data[offset + counter]
        data[offset + counter] = data[offset + temp]
        data[offset + temp] = prev
        counter = counter + -1
    data_to_decrypt = data[offset:offset+0x31]
    decBytes = cipher.decrypt(data_to_decrypt)
    data[offset:offset+0x31] = decBytes
    print(decBytes.decode())

# Translation of SUB_1BBF
def d_sub_b():
    counter = 0
    while counter < 10:
        if (data[KDD_S + counter * 0x32] & 4) != 0:
            rc4_decrypt(rc4_key, KDD_S + counter * 0x32)
            data[KDD_S + counter * 0x32] = 8
        counter += 1

# Translation of SUB_2ECE
def derive_key(keyValue):
    counter = 0
    while True:
        if 9 < counter:
            d_sub_b()
            recValue = derive_key(keyValue)
            return recValue
        ind = counter * 0x32 + 0x51a1
        if (data[KDD_S + counter*0x32] & 8) and keyValue in data[ind:ind+4]:
            break
        counter += 1
    return counter * 0x32 + 0x51a5

def decrypt_config(number):
    iv = derive_key(ivValueData)
    key = derive_key(keyValueData)
    iv = bytes(data[iv:iv+16])
    key = bytes(data[key:key+32])

    cbc = AES.new(key, AES.MODE_CBC, IV=iv)
    ind = number * 0x61 + 1
    data_to_decrypt = data[ECO_S+ind:ECO_S+ind+0x60]
    decrypted_data = cbc.decrypt(data_to_decrypt)
    data[ECO_S+ind:ECO_S+ind+0x60] = decrypted_data

for i in range(22):
    decrypt_config(i)

print(bytes(data[ECO_S:ECO_E]).decode())

````

Result of decrypting:

* stky7a9d6fad3798a7867a9d6fad3798a786
* contbhuwehobiwsnbqpxnws.damctf.xyz
* jgiegoogle.com
* slti300
* xveefacebook.com
* flagdam{1m4g1n3_m4k1ng_w1nd0ws_m4lw4re_lma0}
* ehbnamazon.com
* bnwemicrosoft.com
* stivf83646fad02d42e6
* port3613
* IVnoopacknetwuserrunsruncdownupldexitr/etc/passwd/etc/shadow/etc/sudoers%s%s%sfailgoodwskip0123456789abcdefaaaaaaaa-aaaa-4aaa-baaa-aaaaaaaaaaaa/tmp/


Flag: `dam{1m4g1n3_m4k1ng_w1nd0ws_m4lw4re_lma0}`